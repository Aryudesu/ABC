＝＝＝＝＝＝＝＝＝逆引きテンプレメモ

1. 区間の和／最大　個数＋単点更新
　→フェニ木 or セグ木
　→k人目　等はフェニ木で二分探索

2. 区間に+k加算／最大・最小
　→遅延セグ木
　# セグ木Beats　とは

3. 値の大小比較　xより大きい要素の数
　→Clamp　or SortedList

4. 部分木クエリ　木×区間
　→Eulerツアー + フェニ木／セグ木

5. 状態×状態
　→多次元BFS
　→BFS／0-1 BFS／Dijkstra

6. O(N√N)が許されそう　＋　区間に対しての操作
　→Mo's Algorithm

7. 前計算 + nが2000～5000
　→DP

8. 変化する列 × 全体の最適値
　→優先度付きキュー or multiset

9. 多項式／FPS／畳み込み
　→FPS

10.文字列部分一致等
　→ロリハ or SA/LCP


＝＝＝＝＝＝＝＝＝考え方メモ
■問題開いたら制約確認

・N, Q <= 2000　→ O(N^2)，O(NQ)，多次元DP，区間DP

・N, Q <= 10^5　→ O(N logN)，O((N+Q)logN)，O(N√N)

・値が小さい　→値側に次元を持つDPの可能性

・時間制限が3～5sec　→O(N√N)でもいけそう


■更新とクエリの有無
更新なし＋区間クエリ
・累積和
・いもす
・ソート＋二分探索

単点更新＋区間クエリ（min/ max/ sum等）
・フェニ木 or セグ木　（A[x] += vだったり，A[x] = vだったり）

区間更新 + 区間クエリ
遅延セグ木
・[l, r]の範囲に + v

値の大小関係
→座標圧縮 + フェニ木2つ / セグ木


■グラフ系
最短距離系
・重みなし：　BFS
・0/1重み：　0-1BFS
・非負整数：　Dijkstra
・負辺あり（閉路なし）：　DAG+DP
・負辺あり（閉路あり：　ベルマンフォード/SPFA


状態の変化
・向きがある
・スイッチON/OFF
・乗り物に乗る・降りる
・持ち物がある
・壁を壊した階数に制限
・Aモード・Bモード
→拡張Dijkstra


木
・Eulerツアー + フェニ木 / セグ木
・木DP
・LCA / binary lisfting

2点間距離→LCA+dist = depth[u] + depth[v] - 2depth[lca]


■DP
ナップサック系  dp[i][w] = i番目まで見て重さwのときの価値
bitDP  dp[mask][last]
digit DP   dp[pos][less][state]
区間DP　dp[l][r] = 区間[l, r)の最適値
木DP　部分木情報を持って親に渡す

☆状態数を10^7以内に落とす削り方を考える


■クエリ問題
オンライン
・フェニ木/セグ木/平衡二分木
・UnionFind
・優先度付きキュー

オフライン
・ソートしてまとめて処理
・逆から処理
・Mo's alogrithm
・クエリをadd/ remove/ adskに分解

条件を満たす最初の場所
→二分探索＋判定（フェニ木を使うことも視野に入れる）



■数え上げ
順列等
・二項係数，nPk，DP

制約付き並び
・DP
・包除
・FPS

連続した区間に1を置くパターン数
→DPとか空白の区切り方とか

N<=5000くらい　→2変数DPの可能性



＝＝＝＝＝＝＝＝＝　困ったとき
・制約の再確認（値のサイズ等）

・前からではなく後ろからの可能性
・「要素を追加」でなく「要素を削除」する方法
・逆操作を考慮する

・典型手法との対応再確認
　グラフ，DP，区間，木どれでもない？

・情報を減らせるか考える
　座標圧縮，対称性，同じ値でまとめる

・小さいケースから推測
　パターン推測
　不変量や式を見つけ出す
